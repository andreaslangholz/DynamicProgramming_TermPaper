temp.tdum <- kronecker(temp.dum,temp.tdum)
temp.tdum <- kronecker(temp.dum,dummy)
temp.tdum <- c(n.lags:n.periods)
temp.tdum <- kronecker(temp.dum,dummy)
kronecker(kronecker((temp.tdum,rep(1,n.neighborhoods),rep(n.neighborhoods,1)))
kronecker(kronecker(temp.tdum,rep(1,n.neighborhoods)),rep(n.neighborhoods,1))
temp.tdum
kronekcer(temp.tdum,rep(1,n.neighborhoods))
kronecker(temp.tdum,rep(1,n.neighborhoods))
kronecker(kronecker(temp.tdum,rep(1,n.neighborhoods)),rep(1,n.neighborhoods))
kronecker(kronecker(temp.tdum,rep(1,n.neighborhoods)),rep(1,n.neighborhoods))*dummy
as.matrix(kronecker(kronecker(temp.tdum,rep(1,n.neighborhoods)),rep(1,n.neighborhoods)))*dummy
dummy <- dummy(temp.dum[(n.lags * n.neighborhoods + 1):length(temp.dum)])
kronecker(temp.tdum,rep(1,n.neighborhoods))
temp.tdum <- c((n.lags+1):n.periods)
kronecker(temp.tdum,rep(1,n.neighborhoods))*dummy
temp.tdum <- c((n.lags+1):n.periods)
as.matrix(kronecker(temp.tdum,rep(1,n.neighborhoods)))*dummy
as.matrix(kronecker(temp.tdum,rep(1,n.neighborhoods)))
dummy * as.matrix(kronecker(temp.tdum,rep(1,n.neighborhoods)))
dummy * as.vector(kronecker(temp.tdum,rep(1,n.neighborhoods)))
n.lags = 2
temp.dum <- rep(c(1:n.neighborhoods), n.periods)
dummy <- dummy(temp.dum[(n.lags * n.neighborhoods + 1):length(temp.dum)])
temp.tdum <- c((n.lags+1):n.periods)
dummy.time <- dummy * as.vector(kronecker(temp.tdum,rep(1,n.neighborhoods)))
matrix(3,1,3)
solve(matrix(3,1,3))
solve(matrix(1:3,3,3))
solve(matrix(1::0.53,3,3))
solve(matrix(1:0.5:3,3,3))
val.vec = as.matrix(as.vector(value.functions.tilde[m,1:n.neighboorhoods, ]))
val.vec = as.matrix(as.vector(value.functions.tilde[m,1:n.neighborhoods, ]))
temp = as.matrix(cbind(val.vec, crime.vec, poll.vec))
templag1 = rbind(matrix(0,nrow = n.neighborhoods,5),temp[1:(length(temp) - n.neighborhoods), ]))
templag1 = rbind(matrix(0,nrow = n.neighborhoods,5), temp[1:(length(temp) - n.neighborhoods), ])
temp = as.matrix(cbind(val.vec, crime.vec, poll.vec))
length(temp)
nrow(temp)
templag1 = rbind(matrix(0,nrow = n.neighborhoods,5), temp[1:(nrow(temp) - n.neighborhoods), ])
templag1 = rbind(matrix(0,nrow = n.neighborhoods, 3), temp[1:(nrow(temp) - n.neighborhoods), ])
templag2 = rbind(matrix(0,nrow = (n.neighborhoods * 2), 3), temp[1:nrow(length(temp) - n.neighborhoods * 2), ])
templag2 = rbind(matrix(0,nrow = (n.neighborhoods * 2), 3), temp[1:nrow(temp) - n.neighborhoods * 2), ])
templag2 = rbind(matrix(0,nrow = (n.neighborhoods * 2), 3), temp[1:(nrow(temp) - n.neighborhoods * 2), ])
lags = cbind(templag1, templag2)
Y = temp[(2 * n.neighborhoods + 1):length(temp), 1]
Y = temp[(2 * n.neighborhoods + 1):nrow(temp), 1]
X = cbind(dummy, dummy.time, lags[(2 * n.neighborhoods + 1):length(lags), ])
X = cbind(dummy, dummy.time, lags[(2 * n.neighborhoods + 1):nrow(lags), ])
beta[ ,m] <- solve(X %*% t(X)) %*% t(X) %*% Y
X %*% t(X)
t(X) %*% X
beta[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
betam = array()
betam[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
showMethods('lm')
lm
solve(t(X) %*% X) %*% (t(X) %*% Y)
solve(t(X) %*% X) %*% (t(X) %*% Y)
ginv(t(X) %*% X) %*% (t(X) %*% Y)
ginv(t(X) %*% X) %*% t(X) %*% Y
lm(Y ~ X)
view(X)
View(X)
View(dummy)
setNames(dummy, C("dum1","dum2","dum3","dum4","dum5"))
setNames(dummy, c("dum1","dum2","dum3","dum4","dum5"))
n.lags = 2
dummy <- rep(c(1:n.neighborhoods), n.periods)
dummy <- dummy(temp.dum[(n.lags * n.neighborhoods + 1):length(temp.dum)])
time = dummy
dummy.time <- c((n.lags+1):n.periods)
dummy.time <- time * as.vector(kronecker(temp.tdum,rep(1,n.neighborhoods)))
val.vec = as.matrix(as.vector(value.functions.tilde[m,1:n.neighboorhoods, ]))
val.vec = as.matrix(as.vector(value.functions.tilde[m,1:n.neighborhoods, ]))
temp = as.matrix(cbind(val.vec, crime.vec, poll.vec))
length
val.vec = as.matrix(as.vector(value.functions.tilde[m,1:n.neighborhoods, ]))
temp = as.matrix(cbind(val.vec, crime.vec, poll.vec))
templag1 = rbind(matrix(0,nrow = n.neighborhoods,5),temp[1:(nrow(temp) - n.neighborhoods), ])
templag1 = rbind(matrix(0,nrow = n.neighborhoods,3),temp[1:(nrow(temp) - n.neighborhoods), ])
templag2 = rbind(matrix(0,nrow = (n.neighborhoods * 2),3),temp[1:(nrow(temp) - n.neighborhoods * 2), ])
lags = cbind(templag1, templag2)
View(X)
n.lags = 2
dummy <- rep(c(1:n.neighborhoods), n.periods)
dummy <- dummy(temp.dum[(n.lags * n.neighborhoods + 1):length(temp.dum)])
time = dummy
dummy.time <- c((n.lags+1):n.periods)
dummy.time <- time * as.vector(kronecker(temp.tdum,rep(1,n.neighborhoods)))
val.vec = as.matrix(as.vector(value.functions.tilde[m,1:n.neighborhoods, ]))
temp = as.matrix(cbind(val.vec, crime.vec, poll.vec))
templag1 = rbind(matrix(0,nrow = n.neighborhoods,3),temp[1:(nrow(temp) - n.neighborhoods), ])
templag2 = rbind(matrix(0,nrow = (n.neighborhoods * 2),3),temp[1:(nrow(temp) - n.neighborhoods * 2), ])
lags = cbind(templag1, templag2)
Y = temp[(2 * n.neighborhoods + 1):nrow(temp), 1]
X = cbind(dummy, dummy.time, lags[(2 * n.neighborhoods + 1):nrow(lags), ])
beta[ ,m] <- solve(X %*% t(X)) %*% t(X) %*% Y
beta[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
beta[ ] <- solve(t(X) %*% X) %*% t(X) %*% Y
solve(t(X) %*% X) %*% t(X) %*% Y
betam[,m]<- solve(t(X) %*% X) %*% t(X) %*% Y
betam[,m]<- solve(t(X) %*% X) %*% t(X) %*% Y
betam[,m]<- as.data.frame(solve(t(X) %*% X) %*% t(X) %*% Y)
q<- as.data.frame(solve(t(X) %*% X) %*% t(X) %*% Y)
length(q)
betam = matrix(0,nrow = 16, n.types)
beta.m <- as.data.frame(solve(t(X) %*% X) %*% t(X) %*% Y)
beta.m[,1] <- as.data.frame(solve(t(X) %*% X) %*% t(X) %*% Y)
beta.m[,2] <- as.data.frame(solve(t(X) %*% X) %*% t(X) %*% Y)
View(beta.m)
for (m in 1:n.types){
val.vec = as.matrix(as.vector(value.functions.tilde[m,1:n.neighborhoods, ]))
temp = as.matrix(cbind(val.vec, crime.vec, poll.vec))
templag1 = rbind(matrix(0,nrow = n.neighborhoods,3),temp[1:(nrow(temp) - n.neighborhoods), ])
templag2 = rbind(matrix(0,nrow = (n.neighborhoods * 2),3),temp[1:(nrow(temp) - n.neighborhoods * 2), ])
lags = cbind(templag1, templag2)
Y = temp[(2 * n.neighborhoods + 1):nrow(temp), 1]
X = cbind(dummy, dummy.time, lags[(2 * n.neighborhoods + 1):nrow(lags), ])
beta.m[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
}
Y
Y - Z * beta.m
Y - X * beta.m[ ,1]
Y - X %*% beta.m[ ,1]
value.functions.tilde[1,n.neighborhoods, ]
value.functions.tilde[1,n.neighborhoods+1, ]
value.functions.tilde
n.periods
n.types
n.neighborhoods
value.functions.tilde[1,n.neighborhoods+1, ]
as.vector(value.functions.tilde[1,n.neighborhoods+1, ])
as.matrix(as.vector(value.functions.tilde[m,n.neighborhoods + 1, ]))
for (m in 1:n.types) {
val.vec = as.matrix(as.vector(value.functions.tilde[m,1:n.neighborhoods, ]))
temp = as.matrix(cbind(val.vec, crime.vec, poll.vec))
templag1 = rbind(matrix(0,nrow = n.neighborhoods,3),temp[1:(nrow(temp) - n.neighborhoods), ])
templag2 = rbind(matrix(0,nrow = (n.neighborhoods * 2),3),temp[1:(nrow(temp) - n.neighborhoods * 2), ])
lags = cbind(templag1, templag2)
Y = temp[(2 * n.neighborhoods + 1):nrow(temp), 1]
X = cbind(dummy, dummy.time, lags[(2 * n.neighborhoods + 1):nrow(lags), ])
beta.m[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
res.m[ ,m] <- Y - X %*% beta.m[ ,m]
# We find the parameters for the outside option, as we do not have other regressors than the valuefunctions
val.vec.out = as.matrix(as.vector(value.functions.tilde[m,n.neighborhoods + 1, ]))
templag1 = rbind(matrix(0,1,3),val,val.vec.out[1:(nrow(val.vec.out) - 1), ])
templag2 = rbind(matrix(0,2,3),val.vec.out[1:(nrow(val.vec.out) - 2), ])
lags = cbind(templag1, templag2)
Y = val.vec.out[(2 + 1):nrow(val.vec.out), 1]
X = cbind(lags[(2 + 1):nrow(val.vec.out), ])
beta.o[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
res.o[ ,m] <- Y - X %*% beta.o[ ,m]
}
beta.m = data.frame()
res.m = data.frame()
beta.o = data.frame()
res.o = data.frame()
for (m in 1:n.types) {
val.vec = as.matrix(as.vector(value.functions.tilde[m,1:n.neighborhoods, ]))
temp = as.matrix(cbind(val.vec, crime.vec, poll.vec))
templag1 = rbind(matrix(0,nrow = n.neighborhoods,3),temp[1:(nrow(temp) - n.neighborhoods), ])
templag2 = rbind(matrix(0,nrow = (n.neighborhoods * 2),3),temp[1:(nrow(temp) - n.neighborhoods * 2), ])
lags = cbind(templag1, templag2)
Y = temp[(2 * n.neighborhoods + 1):nrow(temp), 1]
X = cbind(dummy, dummy.time, lags[(2 * n.neighborhoods + 1):nrow(lags), ])
beta.m[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
res.m[ ,m] <- Y - X %*% beta.m[ ,m]
# We find the parameters for the outside option, as we do not have other regressors than the valuefunctions
val.vec.out = as.matrix(as.vector(value.functions.tilde[m,n.neighborhoods + 1, ]))
templag1 = rbind(matrix(0,1,3),val,val.vec.out[1:(nrow(val.vec.out) - 1), ])
templag2 = rbind(matrix(0,2,3),val.vec.out[1:(nrow(val.vec.out) - 2), ])
lags = cbind(templag1, templag2)
Y = val.vec.out[(2 + 1):nrow(val.vec.out), 1]
X = cbind(lags[(2 + 1):nrow(val.vec.out), ])
beta.o[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
res.o[ ,m] <- Y - X %*% beta.o[ ,m]
}
data.frame(3,4)
beta.m = as.data.frame(matrix(0,16,9))
res.m = as.data.frame(matrix(0,16,9))
res.o = as.data.frame(matrix(0,16,9))
beta.o = as.data.frame(matrix(0,16,9))
for (m in 1:n.types) {
val.vec = as.matrix(as.vector(value.functions.tilde[m,1:n.neighborhoods, ]))
temp = as.matrix(cbind(val.vec, crime.vec, poll.vec))
templag1 = rbind(matrix(0,nrow = n.neighborhoods,3),temp[1:(nrow(temp) - n.neighborhoods), ])
templag2 = rbind(matrix(0,nrow = (n.neighborhoods * 2),3),temp[1:(nrow(temp) - n.neighborhoods * 2), ])
lags = cbind(templag1, templag2)
Y = temp[(2 * n.neighborhoods + 1):nrow(temp), 1]
X = cbind(dummy, dummy.time, lags[(2 * n.neighborhoods + 1):nrow(lags), ])
beta.m[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
res.m[ ,m] <- Y - X %*% beta.m[ ,m]
# We find the parameters for the outside option, as we do not have other regressors than the valuefunctions
val.vec.out = as.matrix(as.vector(value.functions.tilde[m,n.neighborhoods + 1, ]))
templag1 = rbind(matrix(0,1,3),val,val.vec.out[1:(nrow(val.vec.out) - 1), ])
templag2 = rbind(matrix(0,2,3),val.vec.out[1:(nrow(val.vec.out) - 2), ])
lags = cbind(templag1, templag2)
Y = val.vec.out[(2 + 1):nrow(val.vec.out), 1]
X = cbind(lags[(2 + 1):nrow(val.vec.out), ])
beta.o[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
res.o[ ,m] <- Y - X %*% beta.o[ ,m]
}
res.m = as.data.frame(matrix(0,(n.periods-n.lags)*n.neighborhoods,n.types))
res.o = as.data.frame(matrix(0,(n.periods-n.lags)*n.neighborhoods,n.types))
for (m in 1:n.types) {
val.vec = as.matrix(as.vector(value.functions.tilde[m,1:n.neighborhoods, ]))
temp = as.matrix(cbind(val.vec, crime.vec, poll.vec))
templag1 = rbind(matrix(0,nrow = n.neighborhoods,3),temp[1:(nrow(temp) - n.neighborhoods), ])
templag2 = rbind(matrix(0,nrow = (n.neighborhoods * 2),3),temp[1:(nrow(temp) - n.neighborhoods * 2), ])
lags = cbind(templag1, templag2)
Y = temp[(2 * n.neighborhoods + 1):nrow(temp), 1]
X = cbind(dummy, dummy.time, lags[(2 * n.neighborhoods + 1):nrow(lags), ])
beta.m[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
res.m[ ,m] <- Y - X %*% beta.m[ ,m]
# We find the parameters for the outside option, as we do not have other regressors than the valuefunctions
val.vec.out = as.matrix(as.vector(value.functions.tilde[m,n.neighborhoods + 1, ]))
templag1 = rbind(matrix(0,1,3),val,val.vec.out[1:(nrow(val.vec.out) - 1), ])
templag2 = rbind(matrix(0,2,3),val.vec.out[1:(nrow(val.vec.out) - 2), ])
lags = cbind(templag1, templag2)
Y = val.vec.out[(2 + 1):nrow(val.vec.out), 1]
X = cbind(lags[(2 + 1):nrow(val.vec.out), ])
beta.o[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
res.o[ ,m] <- Y - X %*% beta.o[ ,m]
}
for (m in 1:n.types) {
val.vec = as.matrix(as.vector(value.functions.tilde[m,1:n.neighborhoods, ]))
temp = as.matrix(cbind(val.vec, crime.vec, poll.vec))
templag1 = rbind(matrix(0,nrow = n.neighborhoods,3),temp[1:(nrow(temp) - n.neighborhoods), ])
templag2 = rbind(matrix(0,nrow = (n.neighborhoods * 2),3),temp[1:(nrow(temp) - n.neighborhoods * 2), ])
lags = cbind(templag1, templag2)
Y = temp[(2 * n.neighborhoods + 1):nrow(temp), 1]
X = cbind(dummy, dummy.time, lags[(2 * n.neighborhoods + 1):nrow(lags), ])
beta.m[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
res.m[ ,m] <- Y - X %*% beta.m[ ,m]
# We find the parameters for the outside option, as we do not have other regressors than the valuefunctions
val.vec.out = as.matrix(as.vector(value.functions.tilde[m,n.neighborhoods + 1, ]))
templag1 = rbind(matrix(0,1,3),val.vec.out[1:(nrow(val.vec.out) - 1), ])
templag2 = rbind(matrix(0,2,3),val.vec.out[1:(nrow(val.vec.out) - 2), ])
lags = cbind(templag1, templag2)
Y = val.vec.out[(2 + 1):nrow(val.vec.out), 1]
X = cbind(lags[(2 + 1):nrow(val.vec.out), ])
beta.o[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
res.o[ ,m] <- Y - X %*% beta.o[ ,m]
}
templag1
templag2
X = cbind(dummy, dummy.time, lags[(2 * n.neighborhoods + 1):nrow(lags), ])
for (m in 1:n.types) {
val.vec = as.matrix(as.vector(value.functions.tilde[m,1:n.neighborhoods, ]))
temp = as.matrix(cbind(val.vec, crime.vec, poll.vec))
templag1 = rbind(matrix(0,nrow = n.neighborhoods,3),temp[1:(nrow(temp) - n.neighborhoods), ])
templag2 = rbind(matrix(0,nrow = (n.neighborhoods * 2),3),temp[1:(nrow(temp) - n.neighborhoods * 2), ])
lags = cbind(templag1, templag2)
Y = temp[(2 * n.neighborhoods + 1):nrow(temp), 1]
X = cbind(dummy, dummy.time, lags[(2 * n.neighborhoods + 1):nrow(lags), ])
beta.m[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
res.m[ ,m] <- Y - X %*% beta.m[ ,m]
}
# We fin
templag1
templag1
templag2
val.vec.out
for (m in 1:n.types) {
val.vec = as.matrix(as.vector(value.functions.tilde[m,1:n.neighborhoods, ]))
temp = as.matrix(cbind(val.vec, crime.vec, poll.vec))
templag1 = rbind(matrix(0,nrow = n.neighborhoods,3),temp[1:(nrow(temp) - n.neighborhoods), ])
templag2 = rbind(matrix(0,nrow = (n.neighborhoods * 2),3),temp[1:(nrow(temp) - n.neighborhoods * 2), ])
lags = cbind(templag1, templag2)
Y = temp[(2 * n.neighborhoods + 1):nrow(temp), 1]
X = cbind(dummy, dummy.time, lags[(2 * n.neighborhoods + 1):nrow(lags), ])
beta.m[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
res.m[ ,m] <- Y - X %*% beta.m[ ,m]
# We find the parameters for the outside option, as we do not have other regressors than the valuefunctions
val.vec.out = as.matrix(as.vector(value.functions.tilde[m,n.neighborhoods + 1, ]))
templag1 = rbind(matrix(0,1,1), val.vec.out[1:(nrow(val.vec.out) - 1), ])
templag2 = rbind(matrix(0,2,1), val.vec.out[1:(nrow(val.vec.out) - 2), ])
lags = cbind(templag1, templag2)
Y = val.vec.out[(2 + 1):nrow(val.vec.out), 1]
X = cbind(lags[(2 + 1):nrow(val.vec.out), ])
beta.o[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
res.o[ ,m] <- Y - X %*% beta.o[ ,m]
}
templag2
templag1
val.vec.out
nrow(val.vec.out)
nrow(val.vec.out) - 1
val.vec.out[1:nrow(val.vec.out) - 1,]
matrix[0,2,1]
matrix(0,2,1)
rbind(matrix(0,2,1), val.vec.out[1:nrow(val.vec.out) - 1,])
val.vec.out[1:nrow(val.vec.out) - 1,]
as.matrix(val.vec.out[1:nrow(val.vec.out) - 1,])
rbind(matrix(0,2,1), val.vec.out[1:nrow(val.vec.out) - 1,])
rbind(as.vector(matrix(0,2,1)), val.vec.out[1:nrow(val.vec.out) - 1,])
rbind(matrix(0,2,1), val.vec.out[1:nrow(val.vec.out) - 1])
rbind(matrix(0,2,1), val.vec.out[1:nrow(val.vec.out) - 1])
rbind(as.data.frame(matrix(0,2,1)), val.vec.out[1:nrow(val.vec.out) - 1])
rbind(as.data.frame(matrix(0,2,1)), val.vec.out[1:nrow(val.vec.out) - 1,])
rbind(as.data.frame(matrix(0,2,1)), as.data.frame(val.vec.out[1:nrow(val.vec.out) - 1,]))
as.data.frame(val.vec.out[1:nrow(val.vec.out) - 1,]
as.data.frame(val.vec.out[1:nrow(val.vec.out) - 1,])
val.vec.out[1:nrow(val.vec.out) - 1,
val.vec.out[1:nrow(val.vec.out) - 1,]
outside option--dont have other x variables for outside option
temp = [squeeze(squeeze(valuetildeMb(m,J+1,:)))];
templag1=[zeros(1,1);temp(1:(end-1),:)];
templag2=[zeros(2*1,1);temp(1:(end-2*1),:)];
y=temp;
val.vec.out[1:nrow(val.vec.out) - 1,]
as.matrix(val.vec.out[1:nrow(val.vec.out) - 1,])
matrix(0,1,2)
matrix(0,2,1)
rbind(matrix(0,2,1),as.matrix(val.vec.out[1:nrow(val.vec.out) - 1,]) )
beta.m = as.data.frame(matrix(0,16,9))
res.m = as.data.frame(matrix(0,(n.periods-n.lags)*n.neighborhoods,n.types))
beta.o = as.data.frame(matrix(0,16,9))
res.o = as.data.frame(matrix(0,(n.periods-n.lags)*n.neighborhoods,n.types))
for (m in 1:n.types) {
val.vec = as.matrix(as.vector(value.functions.tilde[m,1:n.neighborhoods, ]))
temp = as.matrix(cbind(val.vec, crime.vec, poll.vec))
templag1 = rbind(matrix(0,nrow = n.neighborhoods,3),temp[1:(nrow(temp) - n.neighborhoods), ])
templag2 = rbind(matrix(0,nrow = (n.neighborhoods * 2),3),temp[1:(nrow(temp) - n.neighborhoods * 2), ])
lags = cbind(templag1, templag2)
Y = temp[(2 * n.neighborhoods + 1):nrow(temp), 1]
X = cbind(dummy, dummy.time, lags[(2 * n.neighborhoods + 1):nrow(lags), ])
beta.m[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
res.m[ ,m] <- Y - X %*% beta.m[ ,m]
# We find the parameters for the outside option, as we do not have other regressors than the valuefunctions
val.vec.out = as.matrix(as.vector(value.functions.tilde[m,n.neighborhoods + 1, ]))
templag1 = rbind(matrix(0,1,1), as.matrix(val.vec.out[1:(nrow(val.vec.out) - 1), ])
templag2 = rbind(matrix(0,2,1), as.matrix(val.vec.out[1:(nrow(val.vec.out) - 2), ])
lags = cbind(templag1, templag2)
Y = val.vec.out[(2 + 1):nrow(val.vec.out), 1]
X = cbind(lags[(2 + 1):nrow(val.vec.out), ])
beta.o[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
res.o[ ,m] <- Y - X %*% beta.o[ ,m]
}
templag1 = rbind(matrix(0,1,1), as.matrix(val.vec.out[1:(nrow(val.vec.out) - 1), ]))
templag2 = rbind(matrix(0,2,1), as.matrix(val.vec.out[1:(nrow(val.vec.out) - 2), ]))
lags = cbind(templag1, templag2)
lags
beta.m = as.data.frame(matrix(0,16,9))
res.m = as.data.frame(matrix(0,(n.periods-n.lags)*n.neighborhoods,n.types))
beta.o = as.data.frame(matrix(0,16,9))
res.o = as.data.frame(matrix(0,(n.periods-n.lags)*n.neighborhoods,n.types))
for (m in 1:n.types) {
val.vec = as.matrix(as.vector(value.functions.tilde[m,1:n.neighborhoods, ]))
temp = as.matrix(cbind(val.vec, crime.vec, poll.vec))
templag1 = rbind(matrix(0,nrow = n.neighborhoods,3),temp[1:(nrow(temp) - n.neighborhoods), ])
templag2 = rbind(matrix(0,nrow = (n.neighborhoods * 2),3),temp[1:(nrow(temp) - n.neighborhoods * 2), ])
lags = cbind(templag1, templag2)
Y = temp[(2 * n.neighborhoods + 1):nrow(temp), 1]
X = cbind(dummy, dummy.time, lags[(2 * n.neighborhoods + 1):nrow(lags), ])
beta.m[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
res.m[ ,m] <- Y - X %*% beta.m[ ,m]
# We find the parameters for the outside option, as we do not have other regressors than the valuefunctions
val.vec.out = as.matrix(as.vector(value.functions.tilde[m,n.neighborhoods + 1, ]))
templag1 = rbind(matrix(0,1,1), as.matrix(val.vec.out[1:(nrow(val.vec.out) - 1), ]))
templag2 = rbind(matrix(0,2,1), as.matrix(val.vec.out[1:(nrow(val.vec.out) - 2), ]))
lags = cbind(templag1, templag2)
Y = val.vec.out[(2 + 1):nrow(val.vec.out), 1]
X = cbind(lags[(2 + 1):nrow(val.vec.out), ])
beta.o[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
res.o[ ,m] <- Y - X %*% beta.o[ ,m]
}
for (m in 1:n.types) {
beta.o = as.data.frame(matrix(0,2,9))
beta.o = as.data.frame(matrix(0,2,9))
beta.o = as.data.frame(matrix(0,2,9))
res.o = as.data.frame(matrix(0,(n.periods-n.lags)*n.neighborhoods,n.types))
for (m in 1:n.types) {
val.vec = as.matrix(as.vector(value.functions.tilde[m,1:n.neighborhoods, ]))
temp = as.matrix(cbind(val.vec, crime.vec, poll.vec))
templag1 = rbind(matrix(0,nrow = n.neighborhoods,3),temp[1:(nrow(temp) - n.neighborhoods), ])
templag2 = rbind(matrix(0,nrow = (n.neighborhoods * 2),3),temp[1:(nrow(temp) - n.neighborhoods * 2), ])
lags = cbind(templag1, templag2)
Y = temp[(2 * n.neighborhoods + 1):nrow(temp), 1]
X = cbind(dummy, dummy.time, lags[(2 * n.neighborhoods + 1):nrow(lags), ])
beta.m[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
res.m[ ,m] <- Y - X %*% beta.m[ ,m]
# We find the parameters for the outside option, as we do not have other regressors than the valuefunctions
val.vec.out = as.matrix(as.vector(value.functions.tilde[m,n.neighborhoods + 1, ]))
templag1 = rbind(matrix(0,1,1), as.matrix(val.vec.out[1:(nrow(val.vec.out) - 1), ]))
templag2 = rbind(matrix(0,2,1), as.matrix(val.vec.out[1:(nrow(val.vec.out) - 2), ]))
lags = cbind(templag1, templag2)
Y = val.vec.out[(2 + 1):nrow(val.vec.out), 1]
X = cbind(lags[(2 + 1):nrow(val.vec.out), ])
beta.o[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
res.o[ ,m] <- Y - X %*% beta.o[ ,m]
}
res.o = as.data.frame(matrix(0,8,n.types))
for (m in 1:n.types) {
val.vec = as.matrix(as.vector(value.functions.tilde[m,1:n.neighborhoods, ]))
temp = as.matrix(cbind(val.vec, crime.vec, poll.vec))
templag1 = rbind(matrix(0,nrow = n.neighborhoods,3),temp[1:(nrow(temp) - n.neighborhoods), ])
templag2 = rbind(matrix(0,nrow = (n.neighborhoods * 2),3),temp[1:(nrow(temp) - n.neighborhoods * 2), ])
lags = cbind(templag1, templag2)
Y = temp[(2 * n.neighborhoods + 1):nrow(temp), 1]
X = cbind(dummy, dummy.time, lags[(2 * n.neighborhoods + 1):nrow(lags), ])
beta.m[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
res.m[ ,m] <- Y - X %*% beta.m[ ,m]
# We find the parameters for the outside option, as we do not have other regressors than the valuefunctions
val.vec.out = as.matrix(as.vector(value.functions.tilde[m,n.neighborhoods + 1, ]))
templag1 = rbind(matrix(0,1,1), as.matrix(val.vec.out[1:(nrow(val.vec.out) - 1), ]))
templag2 = rbind(matrix(0,2,1), as.matrix(val.vec.out[1:(nrow(val.vec.out) - 2), ]))
lags = cbind(templag1, templag2)
Y = val.vec.out[(2 + 1):nrow(val.vec.out), 1]
X = cbind(lags[(2 + 1):nrow(val.vec.out), ])
beta.o[ ,m] <- solve(t(X) %*% X) %*% t(X) %*% Y
res.o[ ,m] <- Y - X %*% beta.o[ ,m]
}
res.o
value.functions.tilde[m,6,]
View(res.m)
meanprices <- data.frame(matrix(0,nrow = n.neighborhoods, ncol = n.periods))
View(zdata)
# Find the mean price level for all years
meanprices <- data.frame(matrix(0,nrow = n.neighborhoods, ncol = n.periods))
for (t in 1:n.periods) {
for (m in 1:n.neighborhoods) {
temp <- subset(zdata, current.year == t & nhood == m)
meanprices[m,t] = mean(temp$price)
}
}
View(meanprices)
subset(zdata, current.year == t & nhood == m)
zdata[ zdata$current.year == t & zdata$nhood == m, ]
for (t in 1:n.periods) {
for (m in 1:n.neighborhoods) {
temp <- subset(zdata, year.ind == t & nhood == m)
meanprices[m,t] = mean(temp$price)
}
}
price.vec <- as.matrix(as.vector(meanprices[1:n.neighborhoods, ]))
temp.t    <- as.matrix(cbind(price.vec, crime.vec, poll.vec))
price.vec
val.vec
price.vec
as.vector(meanprices[1:n.neighborhoods, ])
as.vector(as.matrix(meanprices[1:n.neighborhoods, ]))
as.matrix(as.vector(as.matrix(meanprices[1:n.neighborhoods, ])))
as.matrix(meanprices[1:n.neighborhoods, ])
price.vec <- as.matrix(as.vector(as.matrix(meanprices[1:n.neighborhoods, ])))
temp.t    <- as.matrix(cbind(price.vec, crime.vec, poll.vec))
lag1      <- rbind(matrix(0,nrow = n.neighborhoods, 3), temp.t[1:(nrow(temp.t) - n.neighborhoods), ])
lag2      <- rbind(matrix(0,nrow = (n.neighborhoods * 2), 3), temp.t[1:(nrow(temp.t) - n.neighborhoods * 2), ])
lags      <- cbind(lag1, lag2)
Y <- temp.t[(2 * n.neighborhoods + 1)]:nrow(temp.t), 1]
Y <- temp.t[(2 * n.neighborhoods + 1):nrow(temp.t), 1]
X <- cbins[dummy, dummy.time, lags[(2 * n.neighborhoods + 1)]:nrow(lags), ]
X <- cbind[dummy, dummy.time, lags[(2 * n.neighborhoods + 1)]:nrow(lags), ]
X <- cbind(dummy, dummy.time, lags[(2 * n.neighborhoods + 1)]:nrow(lags), ])
X <- cbind(dummy, dummy.time, lags[(2 * n.neighborhoods + 1):nrow(lags), ])
beta.price[, m] <- solve(t(X) %*% X) %*% t(X) %*% Y
t(X)
t(X) %*% X
solve(t(X) %*% X)
ginv(t(X) %*% X)
beta.price[, m] <- ginv(t(X) %*% X) %*% t(X) %*% Y
beta.price <- as.data.frame(matrix(0, 16, 1))
res.price  <- as.data.frame(matrix(0, (n.periods-n.lags)*n.neighborhoods, 1))
beta.price[, 1] <- ginv(t(X) %*% X) %*% t(X) %*% Y
res.price[, 1]  <- Y - X %*% beta.o[, m]
res.price[, 1]  <- Y - X %*% beta.price[, 1]
lm(Y ~ X)
methods(lm())
gamma <- c(-9.5, 0.02, 0.1, -0.2, 0.006) # will be given by former estimations
gammapmc <- gamma[4:5]
gamma.pmc <- gamma[4:5]
gamma.pmc[1]
gamma.pmc[2]
gamma.fmc <- gamma[1:2]
gamma.pmc <- gamma[4:5]
# We retrieve the mtau values and time invarient moving costs
m.tau = rep(0,n.types)
pmc.inv < - rep(0,n.types)
for (m in 1:n.types){
m.tau[m]   <- (gamma.fmc[1] * type.comb[m,"wealth"] + gamma.fmc[2] * type.comb[m,"income"]) * type.comb[m, "wealth"]
pmc.inv[m] <- (gamma.pmc[1] * type.comb[m,"wealth"] + gamma.pmc[2] * type.comb[m,"income"])
}
pmc.inv < - matrix(0,n.types,1)
pmc.inv < - as.matrix(0,n.types,1)
pmc
pmcinv = 2
pmc.inv = 2
pmc.inv < - matrix(0, n.types ,1)
pmc.invar < - matrix(0, n.types ,1)
pmc.invar <- matrix(0, n.types ,1)
pmc.inv <- matrix(0, n.types ,1)
pmc.inv
for (m in 1:n.types){
m.tau[m]   <- (gamma.fmc[1] * type.comb[m,"wealth"] + gamma.fmc[2] * type.comb[m,"income"]) * type.comb[m, "wealth"]
pmc.inv[m] <- (gamma.pmc[1] * type.comb[m,"wealth"] + gamma.pmc[2] * type.comb[m,"income"])
}
beta <- 0.95
n.neighborhoods
dim(beta.price)
# Kappa is the valuefunction coefficients for the lags, nhood and time trend dummies
kappa0 <- beta.m[1:n.neighborhoods, ]
kappa1 <- beta.m[(n.neighborhoods + 1):(2 * n.neighborhoods), ]
# Alpha is the  valuefunction coefficients  for crime and pollution amenities with lags
alpha11 <- beta.m[(2 * n.neighborhoods + 1):(2 * n.neighborhoods + 3), ]
alpha12 <- beta.m[(2 * n.neighborhoods + 3):(2 * n.neighborhoods + 6), ]
# Omega is the price coefficients for the nhood and time trend dummies
omega0 <- beta.price[1:n.neighborhoods, ]
omega1 <- beta.price[(n.neighborhoods + 1):(2 * n.neighborhoods), ]
# gamma is the price coefficients for the amenities
gamma11 <- beta.price[(2 * n.neighborhoods + 1):(2 * n.neighborhoods + 3), ]
gamma12 <- beta.price[(2 * n.neighborhoods + 3):(2 * n.neighborhoods + 6), ]
